/************************************
 *  THIS SCRIPT IS GENERATED!       *
 *  DO NOT EDIT THIS FILE BY HAND!  *
 ************************************/
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { spawnSync } from "child_process";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function runCmd(bin, args, options = {}) {
  const result = spawnSync(bin, args, {
    stdio: "inherit",
    shell: process.platform === "win32",
    ...options,
  });
  if (result.status !== 0) {
    throw new Error(`Command failed: ${bin} ${args.join(" ")}`);
  }
}

function toPascalCase(segment) {
  return segment
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join("");
}

function opName(method, pathStr) {
  const parts = pathStr.split("/").filter(Boolean).map(toPascalCase);
  return `${method.charAt(0).toUpperCase()}${method
    .slice(1)
    .toLowerCase()}${parts.join("")}`;
}

function safeIdent(name) {
  const cleaned = name.replace(/[^a-zA-Z0-9_]/g, "_");
  return /^\d/.test(cleaned) ? `S_${cleaned}` : cleaned;
}

function buildSchemaConverter(components) {
  const cache = new Map();

  function refName($ref) {
    const match = /^#\/components\/schemas\/(.+)$/.exec($ref);
    return match ? match[1] : null;
  }

  function convert(schema) {
    if (!schema) return "z.any()";
    if (schema.$ref) {
      const name = refName(schema.$ref);
      if (name) {
        return `${safeIdent(name)}Schema`;
      }
      return "z.any()";
    }

    if (schema.oneOf) {
      return `z.union([${schema.oneOf.map(convert).join(", ")}])`;
    }
    if (schema.anyOf) {
      return `z.union([${schema.anyOf.map(convert).join(", ")}])`;
    }
    if (schema.allOf) {
      // Simplistic: intersect all
      return schema.allOf
        .map(convert)
        .reduce((acc, cur) => `z.intersection(${acc}, ${cur})`);
    }

    const isNullable = schema.nullable === true;
    let base;
    switch (schema.type) {
      case "string": {
        if (Array.isArray(schema.enum)) {
          base = `z.enum([${schema.enum
            .map((e) => JSON.stringify(e))
            .join(", ")}])`;
        } else {
          base = "z.string()";
          if (schema.format === "date-time") base += ".datetime()";
          if (schema.format === "uuid") base += ".uuid()";
          if (schema.format === "email") base += ".email()";
        }
        break;
      }
      case "integer": {
        base = "z.number().int()";
        break;
      }
      case "number": {
        base = "z.number()";
        break;
      }
      case "boolean": {
        base = "z.boolean()";
        break;
      }
      case "array": {
        const itemSchema = convert(schema.items || {});
        base = `z.array(${itemSchema})`;
        break;
      }
      case "object": {
        const props = schema.properties || {};
        const required = new Set(schema.required || []);
        const entries = Object.entries(props).map(([key, val]) => {
          const conv = convert(val);
          const optional = required.has(key) ? "" : ".optional()";
          return `${JSON.stringify(key)}: ${conv}${optional}`;
        });
        base = `z.object({${entries.join(", ")}})`;
        if (schema.additionalProperties) {
          const ap =
            schema.additionalProperties === true
              ? "z.any()"
              : convert(schema.additionalProperties);
          base += `.catchall(${ap})`;
        }
        break;
      }
      default: {
        base = "z.any()";
      }
    }
    return isNullable ? `${base}.nullable()` : base;
  }

  function emitComponentSchemas() {
    if (!components || !components.schemas) return "";
    const lines = [];
    for (const [name, schema] of Object.entries(components.schemas)) {
      const ident = `${safeIdent(name)}Schema`;
      if (cache.has(ident)) continue;
      const expr = convert(schema);
      lines.push(`export const ${ident} = ${expr};`);
      cache.set(ident, true);
    }
    return lines.join("\n");
  }

  return { convert, emitComponentSchemas };
}

async function main() {
  const backendRoot = path.resolve(__dirname, "..");
  const repoRoot = path.resolve(backendRoot, "..");
  const openapiPath = path.resolve(backendRoot, "public", "openapi.json");
  const sharedDir = path.resolve(repoRoot, "shared");
  const outTs = path.resolve(sharedDir, "openapi.zod.ts");
  const outJsDir = sharedDir;

  if (!fs.existsSync(openapiPath)) {
    throw new Error(
      `OpenAPI spec not found at ${openapiPath}. Generate it first.`
    );
  }

  if (!fs.existsSync(sharedDir)) {
    fs.mkdirSync(sharedDir, { recursive: true });
  }

  const spec = JSON.parse(fs.readFileSync(openapiPath, "utf8"));
  const { convert, emitComponentSchemas } = buildSchemaConverter(
    spec.components || {}
  );

  const lines = [];
  lines.push("// Generated from OpenAPI. Do not edit by hand.");
  lines.push("import { z } from 'zod';");
  const comp = emitComponentSchemas();
  if (comp) lines.push(comp);
  if (spec.paths) {
    for (const [p, pathItem] of Object.entries(spec.paths)) {
      for (const [method, operation] of Object.entries(pathItem)) {
        const lower = method.toLowerCase();
        if (
          ![
            "get",
            "post",
            "put",
            "patch",
            "delete",
            "options",
            "head",
          ].includes(lower)
        )
          continue;
        const baseName = opName(lower, p);
        const params = Array.isArray(operation.parameters)
          ? operation.parameters
          : [];
        const pathProps = {};
        const queryProps = {};
        for (const param of params) {
          const target =
            param.in === "path"
              ? pathProps
              : param.in === "query"
              ? queryProps
              : null;
          if (!target) continue;
          const sch = param.schema || { type: "string" };
          let expr = convert(sch);
          if (param.required !== true) expr += ".optional()";
          target[param.name] = expr;
        }
        if (Object.keys(pathProps).length > 0) {
          lines.push(
            `export const ${baseName}PathParams = z.object({${Object.entries(
              pathProps
            )
              .map(([k, v]) => `${JSON.stringify(k)}: ${v}`)
              .join(", ")}});`
          );
        }
        if (Object.keys(queryProps).length > 0) {
          lines.push(
            `export const ${baseName}QueryParams = z.object({${Object.entries(
              queryProps
            )
              .map(([k, v]) => `${JSON.stringify(k)}: ${v}`)
              .join(", ")}});`
          );
        }
        const rb =
          operation.requestBody &&
          operation.requestBody.content &&
          (operation.requestBody.content["application/json"] ||
            operation.requestBody.content["application/*+json"]);
        if (rb && rb.schema) {
          const expr = convert(rb.schema);
          lines.push(`export const ${baseName}RequestBody = ${expr};`);
        }
        const responses = operation.responses || {};
        for (const [status, resp] of Object.entries(responses)) {
          const content =
            resp &&
            resp.content &&
            (resp.content["application/json"] ||
              resp.content["application/*+json"]);
          if (content && content.schema) {
            const expr = convert(content.schema);
            lines.push(`export const ${baseName}Response${status} = ${expr};`);
          }
        }
      }
    }
  }

  fs.writeFileSync(outTs, lines.join("\n"), "utf8");

  let tscBin =
    process.platform === "win32"
      ? path.resolve(backendRoot, "node_modules", ".bin", "tsc.cmd")
      : path.resolve(backendRoot, "node_modules", ".bin", "tsc");
  if (!fs.existsSync(tscBin)) {
    tscBin = process.platform === "win32" ? "tsc.cmd" : "tsc";
  }

  runCmd(tscBin, [
    outTs,
    "--outDir",
    outJsDir,
    "--declaration",
    "--module",
    "ES2020",
    "--target",
    "ES2020",
    "--moduleResolution",
    "bundler",
    "--esModuleInterop",
    "--skipLibCheck",
    "--pretty",
    "false",
  ]);

  const emittedJs = path.resolve(sharedDir, "openapi.zod.js");
  if (!fs.existsSync(emittedJs)) {
    const fallback = path.resolve(
      sharedDir,
      path.basename(outTs, ".ts") + ".js"
    );
    if (fs.existsSync(fallback)) {
      fs.renameSync(fallback, emittedJs);
    }
  }

  console.log(`Zod schemas generated: ${emittedJs}`);
  const dtsPath = path.resolve(sharedDir, "openapi.zod.d.ts");
  if (fs.existsSync(dtsPath)) {
    console.log(`Type declarations emitted: ${dtsPath}`);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
